%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <pygtk/pygtk.h>

#include "override_common.h"

#include "rhythmdb.h"
#include "rhythmdb-property-model.h"
#include "rhythmdb-query-model.h"
#include "rhythmdb-query-results.h"

void pyrhythmdb_register_classes (PyObject *d); 
void pyrhythmdb_add_constants (PyObject *module, const gchar *strip_prefix);

/* hacks to deal with the nonstandard class name RHYTHMDB */
#define RHYTHMDB_TYPE_RHYTHMDB RHYTHMDB_TYPE
#define RHYTHMDB_RHYTHMDB(o) RHYTHMDB(o)


/* query model sorting stuff */
typedef struct {
	PyObject *func;
	PyObject *data;
} PyRhythmDBQueryModelSortData;

static void
_rhythmdb_query_model_sort_data_free (PyRhythmDBQueryModelSortData *data)
{
	Py_DECREF (data->func);
	Py_DECREF (data->data);
	g_free (data);
}

static int
_rhythmdb_query_model_sort_func (RhythmDBEntry *a, RhythmDBEntry *b, PyRhythmDBQueryModelSortData *data)
{
	PyObject *args;
	PyObject *py_result;
	PyObject *py_a, *py_b;
	int result;

	py_a = pyg_pointer_new (RHYTHMDB_TYPE_ENTRY, a);
	py_b = pyg_pointer_new (RHYTHMDB_TYPE_ENTRY, b);
	if (data->data)
		args = Py_BuildValue ("(OOO)", py_a, py_b, data->data);
	else
		args = Py_BuildValue ("(O)", py_a, py_b);

	py_result = PyEval_CallObject (data->func, args);
	result = PyInt_AsLong (py_result);

	Py_DECREF (args);
	Py_DECREF (py_result);
	return result;
}
/* end query model sorting stuff */

%%
modulename rhythmdb 
%%
import gtk.Widget as PyGtkWidget_Type
import gobject.GObject as PyGObject_Type 
import gtk.TreeView as PyGtkTreeView_Type
%%
ignore-glob
  *_get_type
  *_quark
%%
ignore
  rhythmdb_entry_get_pointer
  rhythmdb_entry_get_string
  rhythmdb_entry_get_boolean
  rhythmdb_entry_get_uint64
  rhythmdb_entry_get_ulong
  rhythmdb_entry_get_double
  rhythmdb_query_model_tree_path_to_entry
  rhythmdb_query_model_iter_to_entry
%%
override rhythmdb_entry_get kwargs
static PyObject *
_wrap_rhythmdb_entry_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entry", "propid", NULL };
    PyObject *py_propid = NULL;
    PyObject *entry = NULL;
    RhythmDB *db;
    RhythmDBPropType propid;
    GValue value = {0,};
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RhythmDB.entry_get", kwlist, &entry, &py_propid))
        return NULL;
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
        return NULL;

    db = RHYTHMDB (self->obj);
    g_value_init (&value, rhythmdb_get_property_type (db, propid));
    rhythmdb_entry_get(db, pyg_pointer_get (entry, RhythmDBEntry), propid, &value);
    ret = pyg_value_as_pyobject (&value, TRUE);
    g_value_unset (&value);
    if (ret)
        return ret;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rhythmdb_entry_set kwargs
static PyObject *
_wrap_rhythmdb_entry_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entry", "propid", "value", NULL };
    PyObject *py_entry = NULL;
    PyObject *py_propid = NULL;
    PyObject *py_value = NULL;
    RhythmDBEntry *entry;
    RhythmDBPropType propid;
    GValue value = {0,};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RhythmDBEntry.set", kwlist, &py_entry, &py_propid, &py_value))
        return NULL;
    if (pyg_pointer_check(py_entry, RHYTHMDB_TYPE_ENTRY))
        entry = pyg_pointer_get(py_entry, RhythmDBEntry);
    else {
        PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
        return NULL;
    }
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
        return NULL;
    g_value_init(&value, rhythmdb_get_property_type (RHYTHMDB(self->obj), propid));
    if (pyg_value_from_pyobject(&value, py_value) < 0) {
        PyErr_SetString(PyExc_TypeError,
		"could not convert argument to correct param type");
        return NULL;
    }
    rhythmdb_entry_set(RHYTHMDB(self->obj), entry, propid, &value);
    g_value_unset (&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rhythmdb_entry_set_nonotify kwargs
static PyObject *
_wrap_rhythmdb_entry_set_nonotify(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entry", "propid", "value", NULL };
    PyObject *py_entry = NULL;
    PyObject *py_propid = NULL;
    PyObject *py_value = NULL;
    RhythmDBEntry *entry;
    RhythmDBPropType propid;
    GValue value = {0,};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RhythmDBEntry.set_nonotify", kwlist, &py_entry, &py_propid, &py_value))
        return NULL;
    if (pyg_pointer_check(py_entry, RHYTHMDB_TYPE_ENTRY))
        entry = pyg_pointer_get(py_entry, RhythmDBEntry);
    else {
        PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
        return NULL;
    }
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
        return NULL;
    g_value_init(&value, rhythmdb_get_property_type (RHYTHMDB(self->obj), propid));
    if (pyg_value_from_pyobject(&value, py_value) < 0) {
        PyErr_SetString(PyExc_TypeError,
		"could not convert argument to correct param type");
        return NULL;
    }
    rhythmdb_entry_set_nonotify(RHYTHMDB(self->obj), entry, propid, &value);
    g_value_unset (&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rhythmdb_entry_set_uninserted kwargs
static PyObject *
_wrap_rhythmdb_entry_set_uninserted(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entry", "propid", "value", NULL };
    PyObject *py_entry = NULL;
    PyObject *py_propid = NULL;
    PyObject *py_value = NULL;
    RhythmDBEntry *entry;
    RhythmDBPropType propid;
    GValue value = {0,};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RhythmDBEntry.set_uninserted", kwlist, &py_entry, &py_propid, &py_value))
        return NULL;
    if (pyg_pointer_check(py_entry, RHYTHMDB_TYPE_ENTRY))
        entry = pyg_pointer_get(py_entry, RhythmDBEntry);
    else {
        PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
        return NULL;
    }
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
        return NULL;
    g_value_init(&value, rhythmdb_get_property_type (RHYTHMDB(self->obj), propid));
    if (pyg_value_from_pyobject(&value, py_value) < 0) {
        PyErr_SetString(PyExc_TypeError,
		"could not convert argument to correct param type");
        return NULL;
    }
    rhythmdb_entry_set_uninserted(RHYTHMDB(self->obj), entry, propid, &value);
    g_value_unset (&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rhythmdb_query_results_add_results kwargs
static PyObject*
_wrap_rhythmdb_query_results_add_results (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", NULL };
    PyObject *py_entries = NULL;
    int size, i;
    GPtrArray *array;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RhythmDBQueryResults.add_results", kwlist, &py_entries))
        return NULL;

    array = g_ptr_array_new();
    size = PyList_Size(py_entries);
    for (i = 0; i < size; i++) {
        PyObject *py_entry;
        RhythmDBEntry *entry;

        py_entry = PyList_GetItem(py_entries, i);
        if (!pyg_pointer_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
            g_ptr_array_free(array, FALSE);
            return NULL;
        }

	entry = pyg_pointer_get(py_entry, RhythmDBEntry);
        g_ptr_array_add(array, entry);
    }

    rhythmdb_query_results_add_results (RHYTHMDB_QUERY_RESULTS(self->obj), array);
    g_ptr_array_free(array, FALSE);

    Py_INCREF(Py_None);
    return Py_None;

}
%%
override rhythmdb_entry_foreach kwargs

typedef struct {
	PyObject *func;
	PyObject *data;
} PyRhythmDBEntryForeachData;

static void
_rhythmdb_entry_foreach_func (RhythmDBEntry *entry, PyRhythmDBEntryForeachData  *data)
{
	PyObject *args;
	PyObject *result;
	PyObject *py_entry;

	py_entry = pyg_pointer_new (RHYTHMDB_TYPE_ENTRY, entry);
	if (data->data)
		args = Py_BuildValue ("(OO)", py_entry, data->data);
	else
		args = Py_BuildValue ("(O)", py_entry);

	result = PyEval_CallObject (data->func, args);
	Py_DECREF (args);

	Py_DECREF (result);
}

static PyObject*
_wrap_rhythmdb_entry_foreach (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"func", NULL};
	PyRhythmDBEntryForeachData data;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:RhythmDB.entry_foreach",
					 kwlist, &data.func, &data.data))
		return NULL;

	/* verify arguments' integrity */
	if (!PyCallable_Check (data.func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		return NULL;
	}

	rhythmdb_entry_foreach (RHYTHMDB (self->obj), (GFunc)_rhythmdb_entry_foreach_func, &data);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_query_model_new kwargs

static PyObject*
_wrap_rhythmdb_query_model_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"query", "func", "reverse", NULL};
	PyObject *py_query;
	int reverse = 0;
	PyRhythmDBQueryModelSortData *data;
	RhythmDBQueryModel *query_model;

	data = g_new0 (PyRhythmDBQueryModelSortData, 1);

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiO:RhythmDB.query_model_new", kwlist,
					 &py_query, &data->func, &reverse, &data->data)) {
		g_free (data);
		return NULL;
	}

	/* verify arguments' integrity */
	if (!PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		g_free (data);
		return NULL;
	}

	if (!pyg_boxed_check(py_query, RHYTHMDB_TYPE_QUERY)) {
		PyErr_SetString(PyExc_TypeError, "query should be a RhythmDBQuery");
		g_free (data);
		return NULL;
	}

	Py_INCREF (data->func);
	Py_INCREF (data->data);

	if (data->func) {
		query_model = rhythmdb_query_model_new (RHYTHMDB (self->obj), pyg_boxed_get (py_query, RhythmDBQuery),
							(GCompareDataFunc) _rhythmdb_query_model_sort_func,
							data, (GDestroyNotify) _rhythmdb_query_model_sort_data_free,
							(reverse != 0));
	} else {
		query_model = rhythmdb_query_model_new (RHYTHMDB (self->obj), pyg_boxed_get (py_query, RhythmDBQuery),
							NULL, NULL, NULL, FALSE);
	}

	return pygobject_new (G_OBJECT (query_model));
}
%%
override rhythmdb_query_model_set_sort_order kwargs

static PyObject*
_wrap_rhythmdb_query_model_set_sort_order (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"func", "reverse", NULL};
	int reverse = 0;
	PyRhythmDBQueryModelSortData *data;
	RhythmDBQueryModel *query_model;

	data = g_new0 (PyRhythmDBQueryModelSortData, 1);

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iO:RhythmDB.query_model_set_sort_order", kwlist,
					 &data->func, &reverse, &data->data)) {
		g_free (data);
		return NULL;
	}

	/* verify arguments' integrity */
	if (!PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		g_free (data);
		return NULL;
	}

	Py_INCREF (data->func);
	Py_INCREF (data->data);

	rhythmdb_query_model_set_sort_order (RHYTHMDB (self->obj),
					     (GCompareDataFunc) _rhythmdb_query_model_sort_func,
					     data, (GDestroyNotify) _rhythmdb_query_model_sort_data_free,
					     (reverse != 0));

	Py_INCREF(Py_None);
	return Py_None;
}
