%%
headers
#include "config.h"

#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <pygtk/pygtk.h>

#include "override_common.h"
#include "rb-util.h"

#include "rb-string-value-map.h"
#include "rhythmdb.h"
#include "rhythmdb-property-model.h"
#include "rhythmdb-query-model.h"
#include "rhythmdb-query-results.h"


#if PY_VERSION_HEX < 0x02050000
typedef int Py_ssize_t;
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
#endif

void pyrhythmdb_register_classes (PyObject *d); 
void pyrhythmdb_add_constants (PyObject *module, const gchar *strip_prefix);

/* hacks to deal with the nonstandard class name RHYTHMDB */
#define RHYTHMDB_TYPE_RHYTHMDB RHYTHMDB_TYPE
#define RHYTHMDB_RHYTHMDB(o) RHYTHMDB(o)

static PyObject* _wrap_rb_string_value_map_mp_subscript (PyObject *self, PyObject *subscript);
static int _wrap_rb_string_value_map_mp_ass_subscript (PyObject *self, PyObject *subscript, PyObject *py_value);

static void
_py_decref (PyObject *o)
{
	Py_XDECREF (o);
}


/* query model sorting stuff */
typedef struct {
	PyObject *func;
	PyObject *data;
} PyRhythmDBQueryModelSortData;

static void
_rhythmdb_query_model_sort_data_free (PyRhythmDBQueryModelSortData *data)
{
	Py_DECREF (data->func);
	Py_DECREF (data->data);
	g_free (data);
}

static int
_rhythmdb_query_model_sort_func (RhythmDBEntry *a, RhythmDBEntry *b, PyRhythmDBQueryModelSortData *data)
{
	PyObject *args;
	PyObject *py_result;
	PyObject *py_a, *py_b;
	int result;

	py_a = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, a, TRUE, TRUE);
	py_b = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, b, TRUE, TRUE);
	if (data->data)
		args = Py_BuildValue ("(OOO)", py_a, py_b, data->data);
	else
		args = Py_BuildValue ("(OO)", py_a, py_b);

	py_result = PyEval_CallObject (data->func, args);
	result = PyInt_AsLong (py_result);

	Py_DECREF (py_a);
	Py_DECREF (py_b);
	Py_DECREF (args);
	Py_DECREF (py_result);
	return result;
}
/* end query model sorting stuff */

%%
modulename rhythmdb 
%%
import gtk.Widget as PyGtkWidget_Type
import gobject.GObject as PyGObject_Type 
import gtk.TreeView as PyGtkTreeView_Type
%%
ignore-glob
  *_get_type
  *_quark
%%
ignore
  rhythmdb_entry_ref
  rhythmdb_entry_unref
  rhythmdb_entry_get_pointer
  rhythmdb_entry_get_string
  rhythmdb_entry_get_boolean
  rhythmdb_entry_get_uint64
  rhythmdb_entry_get_ulong
  rhythmdb_entry_get_double
  rhythmdb_query_model_tree_path_to_entry
  rhythmdb_query_model_iter_to_entry
%%
override rhythmdb_entry_get kwargs
static PyObject *
_wrap_rhythmdb_entry_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "propid", NULL };
	PyObject *py_propid = NULL;
	PyObject *py_entry = NULL;
	RhythmDB *db;
	RhythmDBPropType propid;
	GValue value = {0,};
	PyObject *ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RhythmDB.entry_get", kwlist, &py_entry, &py_propid))
		return NULL;
	if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
		return NULL;

	if (!pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
		char *s = g_strdup_printf ("entry should be a RhythmDBEntry, is a %s", g_type_name (pyg_type_from_object (py_entry)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}

	db = RHYTHMDB (self->obj);
	g_value_init (&value, rhythmdb_get_property_type (db, propid));
	rhythmdb_entry_get(db, pyg_boxed_get (py_entry, RhythmDBEntry), propid, &value);
	ret = pyg_value_as_pyobject (&value, TRUE);
	g_value_unset (&value);
	if (ret)
		return ret;
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_entry_set kwargs
static PyObject *
_wrap_rhythmdb_entry_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "propid", "value", NULL };
	PyObject *py_entry = NULL;
	PyObject *py_propid = NULL;
	PyObject *py_value = NULL;
	RhythmDBEntry *entry;
	RhythmDBPropType propid;
	GValue value = {0,};
	GType prop_type;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RhythmDBEntry.set", kwlist, &py_entry, &py_propid, &py_value))
		return NULL;
	if (pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY))
		entry = pyg_boxed_get(py_entry, RhythmDBEntry);
	else {
		char *s = g_strdup_printf ("entry should be a RhythmDBEntry, is a %s", g_type_name (pyg_type_from_object (py_entry)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}
	if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, (gint *)&propid))
		return NULL;

	prop_type = rhythmdb_get_property_type (RHYTHMDB(self->obj), propid);
	g_value_init(&value, prop_type);
	if (pyg_value_from_pyobject(&value, py_value) < 0) {
		char *s;

		s = g_strdup_printf ("could not convert argument from type '%s' (%d) to correct type '%s'",
					 g_type_name (pyg_type_from_object (py_value)),
					 (int)pyg_type_from_object (py_value),
					 g_type_name (prop_type));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}
	rhythmdb_entry_set(RHYTHMDB(self->obj), entry, propid, &value);
	g_value_unset (&value);
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_query_results_add_results kwargs
static PyObject*
_wrap_rhythmdb_query_results_add_results (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entries", NULL };
	PyObject *py_entries = NULL;
	int size, i;
	GPtrArray *array;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RhythmDBQueryResults.add_results", kwlist, &py_entries))
		return NULL;

	array = g_ptr_array_new();
	size = PyList_Size(py_entries);
	for (i = 0; i < size; i++) {
		PyObject *py_entry;
		RhythmDBEntry *entry;

		py_entry = PyList_GetItem(py_entries, i);
		if (!pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
			g_ptr_array_free(array, FALSE);
			return NULL;
		}

	entry = pyg_boxed_get(py_entry, RhythmDBEntry);
		g_ptr_array_add(array, entry);
	}

	rhythmdb_query_results_add_results (RHYTHMDB_QUERY_RESULTS(self->obj), array);
	g_ptr_array_free(array, FALSE);

	Py_INCREF(Py_None);
	return Py_None;

}
%%
override rhythmdb_entry_foreach kwargs

typedef struct {
	PyObject *func;
	PyObject *data;
} PyRhythmDBEntryForeachData;

static void
_rhythmdb_entry_foreach_func (RhythmDBEntry *entry, PyRhythmDBEntryForeachData  *data)
{
	PyObject *args;
	PyObject *result;
	PyObject *py_entry;

	py_entry = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, entry, TRUE, TRUE);
	if (data->data) {
		args = Py_BuildValue ("(OO)", py_entry, data->data);
	} else {
		args = Py_BuildValue ("(O)", py_entry);
	}

	result = PyEval_CallObject (data->func, args);
	Py_DECREF (py_entry);
	Py_DECREF (args);
	if (result != NULL) {
		Py_DECREF (result);
	}
}

static PyObject*
_wrap_rhythmdb_entry_foreach (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"func", "data", NULL};
	PyRhythmDBEntryForeachData data;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:RhythmDB.entry_foreach",
					 kwlist, &data.func, &data.data))
		return NULL;

	/* verify arguments' integrity */
	if (!PyCallable_Check (data.func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		return NULL;
	}

	rhythmdb_entry_foreach (RHYTHMDB (self->obj), (GFunc)_rhythmdb_entry_foreach_func, &data);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_query_model_new kwargs

static PyObject*
_wrap_rhythmdb_query_model_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"query", "func", "reverse", "data", NULL};
	PyObject *py_query;
	int reverse = 0;
	PyRhythmDBQueryModelSortData *data;
	RhythmDBQueryModel *query_model;

	data = g_new0 (PyRhythmDBQueryModelSortData, 1);

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiO:RhythmDB.query_model_new", kwlist,
					 &py_query, &data->func, &reverse, &data->data)) {
		g_free (data);
		return NULL;
	}

	/* verify arguments' integrity */
	if (!pyg_boxed_check(py_query, RHYTHMDB_TYPE_QUERY)) {
		PyErr_SetString(PyExc_TypeError, "query should be a RhythmDBQuery");
		g_free (data);
		return NULL;
	}

	if (data->func != NULL && !PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		g_free (data);
		return NULL;
	}

	Py_XINCREF (data->func);
	Py_XINCREF (data->data);

	if (data->func) {
		query_model = rhythmdb_query_model_new (RHYTHMDB (self->obj), pyg_boxed_get (py_query, RhythmDBQuery),
							(GCompareDataFunc) _rhythmdb_query_model_sort_func,
							data, (GDestroyNotify) _rhythmdb_query_model_sort_data_free,
							(reverse != 0));
	} else {
		query_model = rhythmdb_query_model_new (RHYTHMDB (self->obj), pyg_boxed_get (py_query, RhythmDBQuery),
							NULL, NULL, NULL, FALSE);
	}

	return pygobject_new (G_OBJECT (query_model));
}
%%
override rhythmdb_query_model_set_sort_order kwargs

static PyObject*
_wrap_rhythmdb_query_model_set_sort_order (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"func", "reverse", NULL};
	int reverse = 0;
	PyRhythmDBQueryModelSortData *data;

	data = g_new0 (PyRhythmDBQueryModelSortData, 1);

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iO:RhythmDB.query_model_set_sort_order", kwlist,
					 &data->func, &reverse, &data->data)) {
		g_free (data);
		return NULL;
	}

	/* verify arguments' integrity */
	if (!PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		g_free (data);
		return NULL;
	}

	Py_INCREF (data->func);
	Py_INCREF (data->data);

	rhythmdb_query_model_set_sort_order (RHYTHMDB_QUERY_MODEL (self->obj),
						 (GCompareDataFunc) _rhythmdb_query_model_sort_func,
						 data, (GDestroyNotify) _rhythmdb_query_model_sort_data_free,
						 (reverse != 0));

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override-attr  RhythmDBEntryType_.sync_metadata

static void
_wrap_py_entry_type_sync_metadata (RhythmDB *db, RhythmDBEntry *entry,
				   GError **error, PyObject *py_call)
{
	if (PyCallable_Check (py_call)) {
		PyObject *ret, *args, *error;
		PyObject *py_db, *py_entry;

		py_db = pygobject_new (G_OBJECT (db));
		py_entry = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, entry, TRUE, TRUE);
		args = Py_BuildValue ("(OO)", py_db, py_entry);
		ret = PyObject_Call (py_call, args, NULL);

		Py_DECREF (py_db);
		Py_DECREF (py_entry);
		Py_DECREF (ret);

		error = PyErr_Occurred ();
		if (error != NULL) {
			/* TODO: catch any exceptions, and set errors*/
			/*PyErr_Clear ();*/
		}
	} else {
		/* TODO: set error */
	}
}

static PyObject*
_wrap_rhythmdb_entry_type__get_sync_metadata (PyGBoxed *self, void *closure)
{
	RhythmDBEntryType et;

	if (pyg_boxed_check(self, RHYTHMDB_TYPE_ENTRY_TYPE))
		et = pyg_boxed_get(self, RhythmDBEntryType_);
	else {
		char *s = g_strdup_printf ("self should be a RhythmDBEntryType, is a %s", g_type_name (pyg_type_from_object ((PyObject*)self)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}

	if (et->sync_metadata == (RhythmDBEntrySyncFunc)rb_null_function) {
		/* nothing */
		Py_INCREF (Py_None);
		return Py_None;
	} else if (et->sync_metadata == (RhythmDBEntrySyncFunc)_wrap_py_entry_type_sync_metadata) {
		/* it's python */
		PyObject *value = (PyObject*)et->sync_metadata_data;

		Py_INCREF (value);
		return value;
	} else {
		/* FIXME: it's a non-python function */
		return NULL;
	}
}

static int
_wrap_rhythmdb_entry_type__set_sync_metadata (PyGBoxed *self, PyObject *value, void *closure)
{
	RhythmDBEntryType et;

	if (pyg_boxed_check(self, RHYTHMDB_TYPE_ENTRY_TYPE))
		et = pyg_boxed_get(self, RhythmDBEntryType_);
	else {
		char *s = g_strdup_printf ("self should be a RhythmDBEntryType, is a %s", g_type_name (pyg_type_from_object ((PyObject*)self)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return -1;
	}

	if (et->sync_metadata_data && et->sync_metadata_destroy)
		et->sync_metadata_destroy (et->sync_metadata);

	if (value == Py_None) {
		et->sync_metadata = (RhythmDBEntrySyncFunc)rb_null_function;
		et->sync_metadata_data = NULL;
		et->sync_metadata_destroy = NULL;
	} else if (PyCallable_Check (value)) {
		/* method */
		et->sync_metadata = (RhythmDBEntrySyncFunc)_wrap_py_entry_type_sync_metadata;
		Py_INCREF (value);
		et->sync_metadata_data = value;
		et->sync_metadata_destroy = (GDestroyNotify)_py_decref;
	} else {
		PyErr_SetString(PyExc_TypeError, "value must be callable");
		return -1;
	}

	return 0;
}
%%
override-attr  RhythmDBEntryType_.can_sync_metadata

static gboolean
_wrap_py_entry_type_can_sync_metadata (RhythmDB *db, RhythmDBEntry *entry,
					  PyObject *py_call)
{
	gboolean retval = FALSE;

	if (PyCallable_Check (py_call)) {
		PyObject *ret, *args;
		PyObject *py_db, *py_entry;
		int i;

		py_db = pygobject_new (G_OBJECT (db));
		py_entry = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, entry, TRUE, TRUE);
		args = Py_BuildValue ("(OO)", py_db, py_entry);
		ret = PyObject_Call (py_call, args, NULL);

		Py_DECREF (py_db);
		Py_DECREF (py_entry);

		i = PyObject_IsTrue (ret);
		Py_DECREF (ret);
		if (i == 0) {
			retval = FALSE;
		} else if (i > 0) {
			retval = TRUE;
		} else {
			/*TODO: emit error */
		}
	} else {
		/* TODO: emit error */
	}

	return retval;
}

static PyObject*
_wrap_rhythmdb_entry_type__get_can_sync_metadata (PyGBoxed *self, void *closure)
{
	RhythmDBEntryType et;

	if (pyg_boxed_check(self, RHYTHMDB_TYPE_ENTRY_TYPE))
		et = pyg_boxed_get(self, RhythmDBEntryType_);
	else {
		char *s = g_strdup_printf ("self should be a RhythmDBEntryType, is a %s", g_type_name (pyg_type_from_object ((PyObject*)self)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}

	if (et->can_sync_metadata == (RhythmDBEntryCanSyncFunc)rb_false_function) {
		/* always false */
		Py_INCREF (Py_False);
		return Py_False;
	} else if (et->can_sync_metadata == (RhythmDBEntryCanSyncFunc)rb_true_function) {
		/* always true */
		Py_INCREF (Py_True);
		return Py_True;
	} else if (et->can_sync_metadata == (RhythmDBEntryCanSyncFunc)rb_null_function) {
		Py_INCREF (Py_None);
		return Py_None;
	} else if (et->can_sync_metadata == (RhythmDBEntryCanSyncFunc)_wrap_py_entry_type_can_sync_metadata) {
		/* it's python */
		PyObject *value = (PyObject*)et->can_sync_metadata_data;

		Py_INCREF (value);
		return value;
	} else {
		/* FIXME: it's a non-python function */
		return NULL;
	}
}

static int
_wrap_rhythmdb_entry_type__set_can_sync_metadata (PyGBoxed *self, PyObject *value, void *closure)
{
	RhythmDBEntryType et;

	if (pyg_boxed_check(self, RHYTHMDB_TYPE_ENTRY_TYPE))
		et = pyg_boxed_get(self, RhythmDBEntryType_);
	else {
		char *s = g_strdup_printf ("self should be a RhythmDBEntryType, is a %s", g_type_name (pyg_type_from_object ((PyObject*)self)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return -1;
	}

	if (et->can_sync_metadata_data && et->can_sync_metadata_destroy)
		et->can_sync_metadata_destroy (et->can_sync_metadata);

	if (value == Py_False) {
		et->can_sync_metadata = (RhythmDBEntryCanSyncFunc)rb_false_function;
		et->can_sync_metadata_data = NULL;
		et->can_sync_metadata_destroy = NULL;
	} else if (value == Py_True) {
		et->can_sync_metadata = (RhythmDBEntryCanSyncFunc)rb_true_function;
		et->can_sync_metadata_data = NULL;
		et->can_sync_metadata_destroy = NULL;
	} else if (value == Py_None) {
		et->can_sync_metadata = (RhythmDBEntryCanSyncFunc)rb_null_function;
		et->can_sync_metadata_data = NULL;
		et->can_sync_metadata_destroy = NULL;
	} else if (PyCallable_Check (value)) {
		/* method */
		et->can_sync_metadata = (RhythmDBEntryCanSyncFunc)_wrap_py_entry_type_can_sync_metadata;
		Py_INCREF (value);
		et->can_sync_metadata_data = value;
		et->can_sync_metadata_destroy = (GDestroyNotify)_py_decref;
	} else {
		PyErr_SetString(PyExc_TypeError, "value must be callable");
		return -1;
	}

	return 0;
}
%%
override rhythmdb_entry_request_extra_metadata kwargs

static PyObject *
_wrap_rhythmdb_entry_request_extra_metadata(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "property_name", NULL };
	PyObject *py_entry;
	char *property_name;
	GValue *ret;
	RhythmDBEntry *entry = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Os:RhythmDB.entry_request_extra_metadata", kwlist, &py_entry, &property_name))
		return NULL;
	if (pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY))
		entry = pyg_boxed_get(py_entry, RhythmDBEntry);
	else {
		char *s = g_strdup_printf ("entry should be a RhythmDBEntry, is a %s", g_type_name (pyg_type_from_object (py_entry)));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}
	
	ret = rhythmdb_entry_request_extra_metadata(RHYTHMDB_RHYTHMDB(self->obj), entry, property_name);
	
	if (ret) {
		PyObject *py_ret = pyg_value_as_pyobject (ret, TRUE);
		g_value_unset (ret);
		g_free(ret);
		return py_ret;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_emit_entry_extra_metadata_notify kwargs

static PyObject *
_wrap_rhythmdb_emit_entry_extra_metadata_notify(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "property_name", "metadata", NULL };
	PyObject *py_entry;
	char *property_name;
	PyObject *py_metadata;
	RhythmDBEntry *entry = NULL;
	GType type;
	GValue val = {0,};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsO:RhythmDB.emit_entry_extra_metadata_notify", kwlist, &py_entry, &property_name, &py_metadata))
		return NULL;

	if (pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
		entry = pyg_boxed_get(py_entry, RhythmDBEntry);
	} else {
		PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
		return NULL;
	}

	type = (py_metadata == Py_None) ? G_TYPE_POINTER : pyg_type_from_object((PyObject *) py_metadata->ob_type);
	if (!type) {
		PyErr_SetString(PyExc_TypeError, "can't map metadata to GType system");
		return NULL;
	}
	g_value_init (&val, type);
	if (pyg_value_from_pyobject (&val, py_metadata) == -1) {
		g_value_unset (&val);
		return NULL;
	}
	rhythmdb_emit_entry_extra_metadata_notify(RHYTHMDB_RHYTHMDB(self->obj), entry, property_name, &val);
	g_value_unset (&val);
	
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override rhythmdb_query_new noargs

static PyObject *
_wrap_rhythmdb_query_new(PyGObject *self)
{
    RhythmDBQuery *ret;
    
    ret = rhythmdb_query_parse(RHYTHMDB_RHYTHMDB(self->obj), RHYTHMDB_QUERY_END);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(RHYTHMDB_TYPE_QUERY, ret, TRUE, TRUE);
}
%%
override rhythmdb_query_append kwargs

static PyObject *
_wrap_rhythmdb_query_append (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	PyObject *obj;
	RhythmDBQuery *query;
	int i;

	if (PyTuple_Size (args) < 2) {
		PyErr_SetString (PyExc_TypeError, "must have at least two arguments");
		return NULL;
	}

	obj = PyTuple_GetItem (args, 0);
	if (obj != NULL && pyg_boxed_check (obj, RHYTHMDB_TYPE_QUERY))
		query = pyg_boxed_get (obj, RhythmDBQuery);
	else {
		PyErr_SetString (PyExc_TypeError, "query should be a RhythmDBQuery");
		return NULL;
	}

	for (i = 1; i < PyTuple_Size (args); i++) {
		PyObject *criteria, *py_type, *obj;
		RhythmDBQueryType type;
		RhythmDBPropType propid = -1;
		GType gtype;
		GValue value = {0,};

		criteria = PyTuple_GetItem (args, i);
		if (!PySequence_Check (criteria)) {
			PyErr_SetString (PyExc_TypeError, "criteria object is not a sequence");
			return NULL;
		}

		py_type = PySequence_GetItem (criteria, 0);
		if (py_type == NULL) {
			PyErr_SetString (PyExc_TypeError, "criteria sequence has no elements");
			return NULL;
		}
		if (pyg_enum_get_value (RHYTHMDB_TYPE_QUERY_TYPE, py_type, (gpointer)&type)) {
			PyErr_SetString (PyExc_TypeError, "criteria operator is invalid");
			return NULL;
		}

		switch (type) {
		case RHYTHMDB_QUERY_END:
		case RHYTHMDB_QUERY_DISJUNCTION:
			break;
		case RHYTHMDB_QUERY_SUBQUERY:
			if (PySequence_Size (args) != 2) {
				PyErr_SetString (PyExc_TypeError, "wrong number arguments for criteria");
			}
			g_value_init (&value, G_TYPE_POINTER);
			obj = PySequence_GetItem (criteria, 1);
			if (obj && pyg_boxed_check (obj, RHYTHMDB_TYPE_QUERY)) {
				g_value_set_pointer (&value, pyg_boxed_get ( obj, RhythmDBQuery));
			} else {
				Py_XDECREF (obj);
				g_value_unset (&value);
				PyErr_SetString (PyExc_TypeError, "query should be a RhythmDBQuery");
				return NULL;
			}
			Py_DECREF (obj);
			break;
		default:
			if (PySequence_Size (criteria) != 3) {
				PyErr_SetString (PyExc_TypeError, "wrong number arguments for criteria");
				return NULL;
			}

			obj = PySequence_GetItem (criteria, 1);
			if (obj == NULL || pyg_enum_get_value (RHYTHMDB_TYPE_PROP_TYPE, obj, (gpointer)&propid)) {
				Py_XDECREF (obj);
				PyErr_SetString (PyExc_TypeError, "criteria propid is of wrong type");
				return NULL;
			}
			Py_DECREF (obj);

			obj = PySequence_GetItem (criteria, 2);
			if (propid == RHYTHMDB_PROP_TYPE) {
				RhythmDBEntryType et;
				if (pyg_boxed_check(obj, RHYTHMDB_TYPE_ENTRY_TYPE)) {
					et = pyg_boxed_get(obj, RhythmDBEntryType_);
				} else {
					char *s = g_strdup_printf ("self should be a RhythmDBEntryType, is a %s", g_type_name (pyg_type_from_object (obj)));
					PyErr_SetString(PyExc_TypeError, s);
					g_free (s);
					return NULL;
				}
				g_value_init (&value, rhythmdb_get_property_type (RHYTHMDB_RHYTHMDB(self->obj), propid));
				g_value_set_pointer (&value, et);
			} else {
				gtype = pyg_type_from_object ((PyObject *)obj->ob_type);
				if (!gtype) {
					PyErr_SetString (PyExc_TypeError, "can't map metadata to GType system");
					return NULL;
				}
				g_value_init (&value, gtype);
				if (pyg_value_from_pyobject  (&value, obj) < 0) {
					Py_XDECREF (obj);
					PyErr_SetString (PyExc_TypeError, "could not access value for criteria");
					return NULL;
				}
			}
			Py_DECREF (obj);
			break;
		}

		rhythmdb_query_append_params (RHYTHMDB_RHYTHMDB (self->obj), query, type, propid, &value);
		if (G_IS_VALUE (&value))
			g_value_unset (&value);
		Py_DECREF (py_type);
	}
	
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override-slot RBStringValueMap.tp_as_mapping

static Py_ssize_t
_wrap_rb_string_value_map_mp_length (PyObject *self)
{
	RBStringValueMap *map = RB_STRING_VALUE_MAP (((PyGObject *)self)->obj);

	return rb_string_value_map_size (map);
}

static PyObject *
_wrap_rb_string_value_map_mp_subscript (PyObject *self, PyObject *subscript)
{
	RBStringValueMap *map = RB_STRING_VALUE_MAP (((PyGObject *)self)->obj);
	PyObject *py_value = NULL;
	char *key;
	GValue value = {0,};

	if (PyString_Check (subscript) < 0) {
		PyErr_SetString (PyExc_TypeError, "key must be a string");
		return NULL;
	}
	key = PyString_AsString (subscript);
	
	if (!rb_string_value_map_get (map, key, &value)) {
		Py_INCREF(Py_None);
		return Py_None;
	}

	py_value = pyg_value_as_pyobject (&value, TRUE);
	g_value_unset (&value);

	return py_value;
}

static int
_wrap_rb_string_value_map_mp_ass_subscript (PyObject *self, PyObject *subscript, PyObject *py_value)
{
	RBStringValueMap *map = RB_STRING_VALUE_MAP (((PyGObject *)self)->obj);
	char *key;
	GValue value = {0,};
	GType gtype;

	gtype = pyg_type_from_object ((PyObject *)py_value->ob_type);
	if (!gtype) {
		PyErr_SetString (PyExc_TypeError, "can't map metadata to GType system");
		return -1;
	}
	g_value_init (&value, gtype);
	if (pyg_value_from_pyobject  (&value, py_value) < 0) {
		PyErr_SetString (PyExc_TypeError, "could not access value for criteria");
		return -1;
	}

	if (PyString_Check (subscript) < 0) {
		PyErr_SetString (PyExc_TypeError, "key must be a string");
		return -1;
	}
	key = PyString_AsString (subscript);
	
	rb_string_value_map_set (map, key, &value);
	g_value_unset (&value);

	return 0;
}

static PyMappingMethods _wrap_rb_string_value_map_tp_as_mapping = {
	/*(lenfunc)*/ _wrap_rb_string_value_map_mp_length,
	/*(binaryfunc)*/ _wrap_rb_string_value_map_mp_subscript,
	/*(objobjargproc)*/ _wrap_rb_string_value_map_mp_ass_subscript,
};
%%
override rb_string_value_map_get kwargs
static PyObject *
_wrap_rb_string_value_map_get (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"key", NULL };
	PyObject *py_key = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBStringValueMap.get", kwlist, &py_key))
		return NULL;

	return _wrap_rb_string_value_map_mp_subscript ((PyObject*)self, py_key);
}
%%
override rb_string_value_map_set kwargs
static PyObject *
_wrap_rb_string_value_map_set (PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"key", "value", NULL };
	PyObject *py_key = NULL;
	PyObject *py_value = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RBStringValueMap.set", kwlist, &py_key, &py_value))
		return NULL;

	if (_wrap_rb_string_value_map_mp_ass_subscript ((PyObject*)self, py_key, py_value) < 0) {
		return NULL;
	}

	Py_INCREF (Py_None);
	return Py_None;
}
