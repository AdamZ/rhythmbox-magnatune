%%
headers

#include "config.h"

#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <pygtk/pygtk.h>

#include "override_common.h"
#include "rb-util.h"
#include "rb-debug.h"

#include "rb-auto-playlist-source.h"
#include "rb-browser-source.h"
#include "rb-cut-and-paste-code.h"
#include "rb-dialog.h"
#include "rb-entry-view.h"
#include "rb-library-browser.h"
#include "rb-playlist-source.h"
#include "rb-player.h"
#include "rb-player-gst-filter.h"
#include "rb-player-gst-tee.h"
#include "rb-player-gst-data-tee.h"
#include "rb-plugin.h"
#include "rb-property-view.h"
#include "rb-removable-media-manager.h"
#include "rb-removable-media-source.h"
#include "rb-shell.h"
#include "rb-shell-player.h"
#include "rb-source.h"
#include "rb-sourcelist.h"
#include "rb-sourcelist-model.h"
#include "rb-static-playlist-source.h"
#include "rb-uri-dialog.h"

void pyrb_register_classes (PyObject *d);
void pyrb_add_constants (PyObject *module, const gchar *strip_prefix);

/* hacks to deal with the nonstandard class name RHYTHMDB */
#define RHYTHMDB_TYPE_RHYTHMDB RHYTHMDB_TYPE
#define RHYTHMDB_RHYTHMDB(o) RHYTHMDB(o)

%%
modulename rb
%%
import gobject.GObject as PyGObject_Type
import gtk.ActionGroup as PyGtkActionGroup_Type
import gtk.Dialog as PyGtkDialog_Type
import gtk.HBox as PyGtkHBox_Type
import gtk.ScrolledWindow as PyGtkScrolledWindow_Type
import gtk.TreeModel as PyGtkTreeModel_Type
import gtk.TreeModelFilter as PyGtkTreeModelFilter_Type
import gtk.TreeView as PyGtkTreeView_Type
import gtk.TreeViewColumn as PyGtkTreeViewColumn_Type
import gtk.UIManager as PyGtkUIManager_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Window as PyGtkWindow_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type

import gst.Element as PyGstElement_Type

import rhythmdb.StringValueMap as PyRBStringValueMap_Type
import rhythmdb.Entry as PyRhythmDBEntry_Type
import rhythmdb.EntryType as PyRhythmDBEntryType_Type
import rhythmdb.PropertyModel as PyRhythmDBPropertyModel_Type
import rhythmdb.PropertyModelColumn as PyRhythmDBPropertyModelColumn_Type
import rhythmdb.PropType as PyRhythmDBPropType_Type
import rhythmdb.Query as PyRhythmDBQuery_Type
import rhythmdb.QueryModel as PyRhythmDBQueryModel_Type
import rhythmdb.QueryResults as PyRhythmDBQueryResults_Type
import rhythmdb.QueryModelLimitType as PyRhythmDBQueryModelLimitType_Type
import rhythmdb.QueryType as PyRhythmDBQueryType_Type
import rhythmdb.RhythmDB as PyRhythmDB_Type
%%
new-constructor RB_TYPE_BROWSER_SOURCE
new-constructor RB_TYPE_SOURCE
%%
ignore-glob
  *_get_type
  *_quark
%%
override rb_entry_view_get_selected_entries noargs
static PyObject *
_wrap_rb_entry_view_get_selected_entries(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_entry_view_get_selected_entries (RB_ENTRY_VIEW(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, FALSE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_get_property_views noargs
static PyObject *
_wrap_rb_source_get_property_views(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_property_views (RB_SOURCE(self->obj));
    py_list = _helper_wrap_gobject_glist (list);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_get_search_actions noargs
static PyObject *
_wrap_rb_source_get_search_actions(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_search_actions (RB_SOURCE(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_source_get_ui_actions noargs
static PyObject *
_wrap_rb_source_get_ui_actions(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_ui_actions (RB_SOURCE(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_source_cut noargs
static PyObject *
_wrap_rb_source_cut(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_cut (RB_SOURCE(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_copy noargs
static PyObject *
_wrap_rb_source_copy(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_copy (RB_SOURCE(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_paste kwargs
static PyObject *
_wrap_rb_source_paste(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", NULL };
    PyObject *py_entries = NULL;
    GList *entries;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBSource.copy", kwlist, &py_entries))
        return NULL;

    entries = _helper_unwrap_boxed_pylist (py_entries, RHYTHMDB_TYPE_ENTRY);
    rb_source_paste (RB_SOURCE(self->obj), entries);
    g_list_free (entries);

    Py_RETURN_NONE;
}
%%
override rb_source_gather_selected_properties kwargs
static PyObject *
_wrap_rb_source_gather_selected_properties(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "keys", NULL };
	PyObject *py_propid, *py_list;
	int propid;
	GList *list;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBSource.gather_selected_properties", kwlist, &py_propid))
		return NULL;
	if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, &propid))
		return NULL;

	list = rb_source_gather_selected_properties (RB_SOURCE(self->obj), (RhythmDBPropType)propid);
	py_list = _helper_wrap_string_glist (list);
	rb_list_deep_free (list);

	return py_list;
}
%%
override rb_property_view_set_selection kwargs
static PyObject *
_wrap_rb_property_view_set_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *py_strings = NULL;
    GList *strings;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBPropertyView.set_selection", kwlist, &py_strings))
        return NULL;

    strings = _helper_unwrap_string_pylist (py_strings, FALSE);
    rb_property_view_set_selection (RB_PROPERTY_VIEW(self->obj), strings);
    g_list_free (strings);

    Py_RETURN_NONE;
}
%%
override rb_property_view_get_selection noargs
static PyObject *
_wrap_rb_property_view_get_selection(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_property_view_get_selection (RB_PROPERTY_VIEW(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_shell_player_get_volume noargs
static PyObject *
_wrap_rb_shell_player_get_volume(PyGObject *self)
{
    gdouble vol = 0.0;
    GError *error = NULL;

    rb_shell_player_get_volume(RB_SHELL_PLAYER(self->obj), &vol, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyFloat_FromDouble(vol);
}
%%
override rb_shell_player_get_mute noargs
static PyObject *
_wrap_rb_shell_player_get_mute(PyGObject *self)
{
    gboolean muted = FALSE;
    GError *error = NULL;

    rb_shell_player_get_mute(RB_SHELL_PLAYER(self->obj), &muted, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyBool_FromLong((long) muted);
}
%%
override rb_shell_player_get_playing noargs
static PyObject *
_wrap_rb_shell_player_get_playing(PyGObject *self)
{
    gboolean playing = FALSE;
    GError *error = NULL;

    rb_shell_player_get_playing(RB_SHELL_PLAYER(self->obj), &playing, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyBool_FromLong((long) playing);
}
%%
override rb_shell_player_get_playing_time noargs
static PyObject *
_wrap_rb_shell_player_get_playing_time(PyGObject *self)
{
    guint time = 0;
    GError *error = NULL;

    rb_shell_player_get_playing_time(RB_SHELL_PLAYER(self->obj), &time, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyLong_FromLong((long) time);
}
%%
override rb_shell_player_get_playing_path noargs
static PyObject *
_wrap_rb_shell_player_get_playing_path(PyGObject *self)
{
    const char *path = NULL;
    GError *error = NULL;

    rb_shell_player_get_playing_path(RB_SHELL_PLAYER(self->obj), &path, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyString_FromString (path);
}
%%
override RBSource__do_impl_cut
static PyObject *
_wrap_RBSource__do_impl_cut(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_cut", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_cut)
		ret = RB_SOURCE_CLASS(klass)->impl_cut(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_cut not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_boxed_glist (ret, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_cut
static GList *
_wrap_RBSource__proxy_do_impl_cut (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_cut");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_boxed_pylist (py_retval, RHYTHMDB_TYPE_ENTRY);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_copy
static PyObject *
_wrap_RBSource__do_impl_copy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_copy", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_copy)
		ret = RB_SOURCE_CLASS(klass)->impl_copy(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_copy not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_boxed_glist (ret, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_copy
static GList *
_wrap_RBSource__proxy_do_impl_copy (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_copy");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_boxed_pylist (py_retval, RHYTHMDB_TYPE_ENTRY);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_property_views
static PyObject *
_wrap_RBSource__do_impl_get_property_views(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_property_views", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_property_views)
		ret = RB_SOURCE_CLASS(klass)->impl_get_property_views(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_property_views not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_gobject_glist (ret);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_property_views
static GList *
_wrap_RBSource__proxy_do_impl_get_property_views (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_property_views");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_gobject_pylist (py_retval);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_ui_actions
static PyObject *
_wrap_RBSource__do_impl_get_ui_actions(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_ui_actions", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_ui_actions)
		ret = RB_SOURCE_CLASS(klass)->impl_get_ui_actions(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_ui_actions not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_ui_actions
static GList *
_wrap_RBSource__proxy_do_impl_get_ui_actions (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_ui_actions");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_search_actions
static PyObject *
_wrap_RBSource__do_impl_get_search_actions(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_search_actions", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_search_actions)
		ret = RB_SOURCE_CLASS(klass)->impl_get_search_actions(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_search_actions not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_search_actions
static GList *
_wrap_RBSource__proxy_do_impl_get_search_actions (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_search_actions");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override rb_shell_player_get_playback_state noargs
static PyObject *
_wrap_rb_shell_player_get_playback_state(PyGObject *self)
{
    gboolean shuffle = FALSE;
    gboolean repeat = FALSE;

    if (!rb_shell_player_get_playback_state(RB_SHELL_PLAYER(self->obj), &shuffle, &repeat))
        return NULL;

    return Py_BuildValue ("bb", shuffle, repeat);
}
%%
override rb_entry_view_get_sorting_order noargs
static PyObject *
_wrap_rb_entry_view_get_sorting_order(PyGObject *self)
{
    char *column = NULL;
    gint order = 0;
    PyObject *object;

    rb_entry_view_get_sorting_order(RB_ENTRY_VIEW(self->obj), &column, &order);
    object = Py_BuildValue ("si", column, order);
    g_free (column);

    return object;
}
%%
override rb_entry_view_set_fixed_column_width kwargs
static PyObject *
_wrap_rb_entry_view_set_fixed_column_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "column", "renderer", "strings", NULL };
	PyGObject *py_column = NULL;
	PyGObject *py_renderer = NULL;
	PyObject *py_strings = NULL;
	const char **strings;
	int length, i;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RBEntryView.set_fixed_column_width", kwlist,
	    &py_column, &py_renderer, &py_strings))
		return NULL;

	/* build the string list */
	length = PySequence_Length (py_strings);
	if (length < 0)
		return NULL;
	strings = g_new0(const char*, length+1);
	for (i = 0; i < length; i++) {
		PyObject *o;

		o = PySequence_GetItem (py_strings, i);
		strings[i] = PyString_AsString (o);
		Py_DECREF (o);
	}

	rb_entry_view_set_fixed_column_width (RB_ENTRY_VIEW (self->obj),
					      GTK_TREE_VIEW_COLUMN (py_column->obj),
					      GTK_CELL_RENDERER (py_renderer->obj),
					      strings);
	g_free (strings);

	Py_RETURN_NONE;
}
%%
override RBSource__do_impl_paste
static PyObject *
_wrap_RBSource__do_impl_paste(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", "entries",NULL };
	PyGObject *self;
	PyObject *py_entries;
	GList *entries;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:RBSource.impl_paste", kwlist, &PyRBSource_Type, &self, &py_entries))
		return NULL;

	entries = _helper_unwrap_boxed_pylist (py_entries, RHYTHMDB_TYPE_ENTRY);

	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_paste)
		RB_SOURCE_CLASS(klass)->impl_paste(RB_SOURCE(self->obj), entries);
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_paste not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	g_list_free (entries);

	Py_RETURN_NONE;
}
%%
override RBSource__proxy_do_impl_paste
static void
_wrap_RBSource__proxy_do_impl_paste(RBSource *self, GList *entries)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_entries;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_entries = _helper_wrap_boxed_glist (entries, RHYTHMDB_TYPE_ENTRY, FALSE, FALSE);

    py_args = PyTuple_New(1);
    Py_INCREF(py_entries);
    PyTuple_SET_ITEM(py_args, 0, py_entries);

    py_method = PyObject_GetAttrString(py_self, "do_impl_paste");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval should be None");
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

%%
override rb_library_browser_get_property_views noargs
static PyObject *
_wrap_rb_library_browser_get_property_views(PyGObject *self)
{
	PyObject *py_list;
	GList *list;

	list = rb_library_browser_get_property_views (RB_LIBRARY_BROWSER(self->obj));
	py_list = _helper_wrap_gobject_glist (list);
	g_list_free (list);

	return py_list;
}

%%
override rb_library_browser_set_selection kwargs
static PyObject *
_wrap_rb_library_browser_set_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "keys", NULL };
    PyObject *py_keys = NULL;
    PyObject *py_propid = NULL;
    int propid;
    GList *keys;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RBLibraryBrowser.set_selection", kwlist, &py_propid, &py_keys))
        return NULL;
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, &propid))
        return NULL;

    keys = _helper_unwrap_string_pylist (py_keys, FALSE);
    rb_library_browser_set_selection (RB_LIBRARY_BROWSER(self->obj), (RhythmDBPropType)propid, keys);
    g_list_free (keys);

	Py_RETURN_NONE;
}

%%
override rb_source_get_status noargs
static PyObject *
_wrap_rb_source_get_status(PyGObject *self)
{
    char *status_text = NULL;
    char *progress_text = NULL;
    float progress = 0.0f;
    PyObject *tuple;

    rb_source_get_status (RB_SOURCE (self->obj), &status_text, &progress_text, &progress);
    tuple = Py_BuildValue ("ssf", status_text, progress_text, progress);
    g_free (status_text);
    g_free (progress_text);
    return tuple;
}

%%
override RBSource__proxy_do_impl_get_status
static void
_wrap_RBSource__proxy_do_impl_get_status(RBSource *self, char **status_text, char **progress_text, float *progress)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    const char *st, *pt;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_status");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    PyArg_ParseTuple (py_retval, "zzf", &st, &pt, progress);
    if (st)
      *status_text = g_strdup (st);
    else
      *status_text = NULL;
    if (pt)
      *progress_text = g_strdup (pt);
    else
      *progress_text = NULL;

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

%%
override RBSource__do_impl_get_status
static PyObject *
_wrap_RBSource__do_impl_get_status(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *status_text = NULL;
    char *progress_text = NULL;
    float progress = 0.0f;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_status", kwlist, &PyRBSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_SOURCE_CLASS(klass)->impl_get_status) {
	RB_SOURCE_CLASS(klass)->impl_get_status(RB_SOURCE(self->obj), &status_text, &progress_text, &progress);
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_status not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(ssf)", status_text, progress_text, progress);
    g_free (status_text);
    g_free (progress_text);
    return tuple;
}
%%
override rb_debug_real kwargs

static PyObject *
_wrap_rb_debug_real(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "function", "file", "line", "newline", "str", NULL };
    char *function, *file, *str;
    int line, newline;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ssiis:debug_real", kwlist, &function, &file, &line, &newline, &str))
        return NULL;
    rb_debug_real(function, file, line, (newline != 0), "%s", str);
	Py_RETURN_NONE;
}
%%
override RBSource__proxy_do_impl_get_browser_key
static char *
_wrap_RBSource__proxy_do_impl_get_browser_key(RBSource *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    char *ret = NULL;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_browser_key");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
    } else if (PyString_Check(py_retval) == FALSE) {
        /* nothing */
    } else {
    	ret = g_strdup (PyString_AsString(py_retval));
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return ret;
}

%%
override RBSource__do_impl_get_browser_key
static PyObject *
_wrap_RBSource__do_impl_get_browser_key(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *key = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_browser_key", kwlist, &PyRBSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_SOURCE_CLASS(klass)->impl_get_browser_key) {
	key = RB_SOURCE_CLASS(klass)->impl_get_browser_key(RB_SOURCE(self->obj));
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_browser_key not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(s)", key);
    g_free (key);
    return tuple;
}
%%
override RBBrowserSource__proxy_do_impl_get_paned_key
static char *
_wrap_RBBrowserSource__proxy_do_impl_get_paned_key(RBBrowserSource *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    char *ret = NULL;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_paned_key");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
    } else if (PyString_Check(py_retval) == FALSE) {
        /* nothing */
    } else {
    	ret = g_strdup (PyString_AsString(py_retval));
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return ret;
}

%%
override RBBrowserSource__do_impl_get_paned_key
static PyObject *
_wrap_RBBrowserSource__do_impl_get_paned_key(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *key = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBBrowserSource.impl_get_paned_key", kwlist, &PyRBBrowserSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_BROWSER_SOURCE_CLASS(klass)->impl_get_paned_key) {
	key = RB_BROWSER_SOURCE_CLASS(klass)->impl_get_paned_key(RB_BROWSER_SOURCE(self->obj));
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBBrowserSource.impl_get_paned_key not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(s)", key);
    g_free (key);
    return tuple;
}
%%
override rb_removable_media_source_get_mime_types noargs
static PyObject *
_wrap_rb_removable_media_source_get_mime_types(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_removable_media_source_get_mime_types (RB_REMOVABLE_MEDIA_SOURCE (self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_static_playlist_source_add_locations kwargs
static PyObject *
_wrap_rb_static_playlist_source_add_locations (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "locations", NULL };
    PyObject *py_locations = NULL;
    GList *locations;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBStaticPlaylistSoruce.add_locations", kwlist, &py_locations))
        return NULL;

    locations = _helper_unwrap_string_pylist (py_locations, FALSE);
    rb_static_playlist_source_add_locations (RB_STATIC_PLAYLIST_SOURCE (self->obj), locations);
    g_list_free (locations);

    Py_RETURN_NONE;
}
%%
override RBRemovableMediaSource__do_impl_get_mime_types
static PyObject *
_wrap_RBRemovableMediaSource__do_impl_get_mime_types(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBRemovableMediaSource.impl_get_mime_types", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_REMOVABLE_MEDIA_SOURCE_CLASS(klass)->impl_get_mime_types)
		ret = RB_REMOVABLE_MEDIA_SOURCE_CLASS(klass)->impl_get_mime_types(RB_REMOVABLE_MEDIA_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBRemovableMediaSource.impl_get_mime_types not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBRemovableMediaSource__proxy_do_impl_get_mime_types
static GList *
_wrap_RBRemovableMediaSource__proxy_do_impl_get_mime_types (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_mime_types");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override rb_removable_media_manager_queue_transfer kwargs

typedef struct {
	PyObject *func;
	PyObject *data;
} PyCallbackData;

static void
_rb_removable_media_manager_queue_transfer_func (RhythmDBEntry *entry, const char *dest, PyCallbackData *data)
{
	PyObject *args;
	PyObject *result;
	PyObject *py_entry;
	PyGILState_STATE __py_state;

	__py_state = pyg_gil_state_ensure();

	py_entry = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, entry, FALSE, FALSE);
	if (data->data) {
		args = Py_BuildValue ("(OsO)", py_entry, dest, data->data);
	} else {
		args = Py_BuildValue ("(Os)", py_entry, dest);
	}

	result = PyEval_CallObject (data->func, args);
	Py_DECREF (py_entry);
	Py_DECREF (args);
	Py_XDECREF (result);

	Py_DECREF (data->func);
	Py_DECREF (data->data);
	pyg_gil_state_release(__py_state);
}

static PyObject *
_wrap_rb_removable_media_manager_queue_transfer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "dest", "mimetypes", "callback", "data", NULL };
	PyObject *py_entry, *py_mimes;
	char *dest = NULL;
	GList *mimes;
	RhythmDBEntry *entry;
	PyCallbackData *data;

	data = g_new0(PyCallbackData, 1);
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsOO|O:RBRemovableMediaManager.queue_transfer", kwlist,
					 &py_entry, &dest, &py_mimes, &data->func, &data->data))
		return NULL;
	if (pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
		entry = pyg_boxed_get(py_entry, RhythmDBEntry);
	} else {
		PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
		return NULL;
	}
	if (!PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		return NULL;
	}
   	mimes = _helper_unwrap_string_pylist (py_mimes, FALSE);

	rb_removable_media_manager_queue_transfer(RB_REMOVABLE_MEDIA_MANAGER(self->obj), entry, dest, mimes,
		(RBTranferCompleteCallback)_rb_removable_media_manager_queue_transfer_func, data);

	g_list_free (mimes);
	Py_INCREF(Py_None);
	return Py_None;
}

